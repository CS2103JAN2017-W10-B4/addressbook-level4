# A0121668A
###### /java/seedu/address/commons/events/model/ConfigChangedEvent.java
``` java
/**
 * Indicates the configuration in the model has changed
 */
public class ConfigChangedEvent extends BaseEvent {

    public final Config data;

    public ConfigChangedEvent(Config data) {
        this.data = data;
    }

    @Override
    public String toString() {
        return data.toString();
    }
}
```
###### /java/seedu/address/commons/events/model/ShowStatusChangedEvent.java
``` java
/**
 * Indicates the activity display status in the model has changed
 */

public class ShowStatusChangedEvent extends BaseEvent {

    public final String displayStatus;

    public ShowStatusChangedEvent (String data) {
        this.displayStatus = data;
    }

    @Override
    public String toString() {
        return "Currently showing: " + "[" + displayStatus + "]" + " activities";
    }
}
```
###### /java/seedu/address/commons/events/model/WhatsLeftChangedEvent.java
``` java
    @Override
    public String toString() {
        return "number of tasks " + data.getTaskList().size()
                + "," + " number of events " + data.getEventList().size() + ", "
                + "number of tags " + data.getTagList().size();
    }
}
```
###### /java/seedu/address/commons/util/StringUtil.java
``` java
    public static final String TIME_FORMAT_CONSTRAINTS = "Time arguments can only be in this format: "
                            + "HHMM format, e.g. 1200";
    public static final String DATE_FORMAT_CONSTRAINTS = "Date arguments can take only 6 digits, "
                            + "and it should be in DDMMYY format (Day-Month-Year), e.g. 060417";
    public static final int YEAR_CONVERSION_INDEX = 2000;

    public static final String DATE_VALIDATION_REGEX = "([0123][\\d])([01][\\d])([\\d][\\d])";
```
###### /java/seedu/address/commons/util/StringUtil.java
``` java
    /**
     * Parse a String argument into date format.
     * @param dateArg
     * @return time in localTime format
     * @throws DateTimeException
     */
    public static LocalTime parseStringToTime(String timeString) throws DateTimeException {
        //empty start date
        if (timeString == null) throw new DateTimeException(TIME_FORMAT_CONSTRAINTS);
        return LocalTime.parse(timeString, DateTimeFormatter.ofPattern("HHmm"));
    }

```
###### /java/seedu/address/commons/util/StringUtil.java
``` java
    /**
     * Parse a String argument into date format.
     * @param dateString
     * @return time in LocalDate format
     * @throws DateTimeException
     */

    public static LocalDate parseStringToDate(String dateString) throws DateTimeException {
        //empty start date
        if (dateString == null) throw new DateTimeException(DATE_FORMAT_CONSTRAINTS);
        return LocalDate.parse(dateString, DateTimeFormatter.ofPattern("ddMMyy"));

    }

```
###### /java/seedu/address/logic/commands/EditCommand.java
``` java
    /**
     * Checks if input values violates time/date constraint
     * @return true if constraint violated, no otherwise
     */
    private boolean isValidEndDateTime() {

        EndDate endDateToCompare;
        EndTime endTimeToCompare;
        StartDate startDateToCompare;
        StartTime startTimeToCompare;
        ReadOnlyEvent eventToEdit = model.getFilteredEventList().get(filteredActivityListIndex);

        if (editEventDescriptor.getEndDate().isPresent()) {
            endDateToCompare = editEventDescriptor.getEndDate().get();
        } else {
            endDateToCompare = eventToEdit.getEndDate();
        }

        if (editEventDescriptor.getStartDate().isPresent()) {
            startDateToCompare = editEventDescriptor.getStartDate().get();
        } else {
            startDateToCompare = eventToEdit.getStartDate();
        }

        if (editEventDescriptor.getEndTime().isPresent()) {
            endTimeToCompare = editEventDescriptor.getEndTime().get();
        } else {
            endTimeToCompare = eventToEdit.getEndTime();
        }

        if (editEventDescriptor.getStartTime().isPresent()) {
            startTimeToCompare = editEventDescriptor.getStartTime().get();
        } else {
            startTimeToCompare = eventToEdit.getStartTime();
        }

        return Event.isValideEndDateTime(endTimeToCompare, endDateToCompare, startTimeToCompare, startDateToCompare);
    }

```
###### /java/seedu/address/logic/commands/FinishCommand.java
``` java
/**
 * Mark a Task as complete
 */
public class FinishCommand extends Command {

    public static final String COMMAND_WORD = "finish";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": mark the task identified by index number used in the last respective listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 5";

    public static final String MESSAGE_FINISH_TASK_SUCCESS = "Finished task: %1$s";

    private final int filteredActivityListIndex;

    public FinishCommand(int filteredActivityListIndex) {
        assert filteredActivityListIndex > 0;
        this.filteredActivityListIndex = filteredActivityListIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList = model.getFilteredTaskList();

        if (filteredActivityListIndex > lastShownTaskList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask taskToComplete = lastShownTaskList.get(filteredActivityListIndex - 1);
        try {
            ReadOnlyWhatsLeft currState = model.getWhatsLeft();
            ModelManager.setPreviousState(currState);
            model.markTaskAsComplete(taskToComplete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        model.storePreviousCommand("finish");
        return new CommandResult(String.format(MESSAGE_FINISH_TASK_SUCCESS, taskToComplete));
    }
```
###### /java/seedu/address/logic/commands/ReadCommand.java
``` java

/**
 * Reads WhatsLeft from a specific location
 */
public class ReadCommand extends Command {

    private static final Logger logger = LogsCenter.getLogger(MainApp.class);

    public static final String COMMAND_WORD = "read";
    public static final Object MESSAGE_USAGE = COMMAND_WORD
            + ":  Reads the WhatsLeft task storage from given location filepath.\n" + "Parameters: FILEPATH\n"
            + "Example: " + COMMAND_WORD + " C:/Users/Downloads/Desktop/CS2103" + " 1\n" + "Example: " + COMMAND_WORD
            + " /Users/Andy/Downloads";

    public static final String MESSAGE_READ_WHATSLEFT_SUCCESS = "Successfully read WhatsLeft from: %1$s";
    private static final String MESSAGE_SAVE_CONFIG_ERROR = "Failed to read stored WhatsLeft tasklist";
    private static final String MESSAGE_START_WITH_NEW_WHATSLEFT = "Data file not found. "
            + "Will be starting with a sample WhatsLeft";

    private String newFilePath;
    private static Config config;
    private static Storage storage;
    private static JsonUserConfigStorage jsonUserConfigStorage;

    public ReadCommand(String filePath) {
        this.newFilePath = filePath;
        jsonUserConfigStorage = new JsonUserConfigStorage(Config.DEFAULT_CONFIG_FILE);
    }

    public static void setStorage(Storage storageToSet) {
        storage = storageToSet;
    }

    public static void setConfig(Config configToset) {
        config = configToset;
    }

    @Override
    public CommandResult execute() throws CommandException {
        try {
            String fileToRead = newFilePath + "/whatsleft.xml";
            Optional<ReadOnlyWhatsLeft> whatsleftToRead = storage.readWhatsLeft(fileToRead);
            config.setWhatsLeftFilePath(fileToRead);
            saveConfig();
            indicateConfigChanged();
            resetWhatsLeft(whatsleftToRead);
        } catch (IOException e) {
            throw new CommandException(Messages.MESSAGE_INVALID_FILEPATH);
        } catch (DataConversionException dce) {
            throw new CommandException(Messages.MESSAGE_DATA_CONVERSION_FAILURE);
        }
        return new CommandResult(String.format(MESSAGE_READ_WHATSLEFT_SUCCESS, newFilePath));
    }

    /**
     * Update the model with new WhatsLeft data Start a new WhatsLeft record, if
     * there is no whatLeft file found in the specified location.
     *
     * @param whatsleftToRead
     * @throws IOException
     */
    private void resetWhatsLeft(Optional<ReadOnlyWhatsLeft> whatsleftToRead) throws IOException {
        ReadOnlyWhatsLeft newWhatsLeft;
        if (!whatsleftToRead.isPresent()) {
            newWhatsLeft = new WhatsLeft();
            logger.info(MESSAGE_START_WITH_NEW_WHATSLEFT);
        } else {
            newWhatsLeft = whatsleftToRead.get();
        }
        model.resetData(newWhatsLeft);
        storage.saveWhatsLeft(newWhatsLeft);
    }

    private void indicateConfigChanged() {
        EventsCenter.getInstance().post(new ConfigChangedEvent(config));
    }

    /**
     * Update configuration file with new configuration
     *
     * @throws CommandException
     */
    private void saveConfig() throws CommandException {
        try {
            jsonUserConfigStorage.saveUserConfig(config);
        } catch (IOException e) {
            throw new CommandException(MESSAGE_SAVE_CONFIG_ERROR);
        }
    }
}
```
###### /java/seedu/address/logic/commands/RedoCommand.java
``` java
/**
 * Mark a Task as complete
 */
public class RedoCommand extends Command {

    public static final String COMMAND_WORD = "redo";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": mark the task identified by index number used in the last respective listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n" + "Example: " + COMMAND_WORD + " 5";

    public static final String MESSAGE_REDO_TASK_SUCCESS = "Redo task: %1$s";

    private final int filteredActivityListIndex;

    public RedoCommand(int filteredActivityListIndex) {
        assert filteredActivityListIndex > 0;
        this.filteredActivityListIndex = filteredActivityListIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {

        UnmodifiableObservableList<ReadOnlyTask> lastShownTaskList = model.getFilteredTaskList();

        if (filteredActivityListIndex > lastShownTaskList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }
        ReadOnlyTask taskToRedo = lastShownTaskList.get(filteredActivityListIndex - 1);
        try {
            ReadOnlyWhatsLeft currState = model.getWhatsLeft();
            ModelManager.setPreviousState(currState);
            model.markTaskAsPending(taskToRedo);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }
        model.storePreviousCommand("redo");
        return new CommandResult(String.format(MESSAGE_REDO_TASK_SUCCESS, taskToRedo));
    }
```
###### /java/seedu/address/logic/commands/SaveCommand.java
``` java

/**
 * Saves WhatsLeft to a designated location
 */
public class SaveCommand extends Command {

    public static final String COMMAND_WORD = "save";
    public static final Object MESSAGE_USAGE = COMMAND_WORD
            + ":  Saves the current WhatsLeft location to the given filepath.\n" + "Parameters: FILEPATH\n"
            + "Example: " + COMMAND_WORD + " C:/Users/Downloads/Desktop/CS2103" + " 1\n" + "Example: " + COMMAND_WORD
            + " /Users/Andy/Downloads";

    public static final String MESSAGE_CHANGE_FILEPATH_SUCCESS = "Saved WhatsLeft to: %1$s";
    private static final String MESSAGE_SAVE_CONFIG_ERROR = "Failed to save configuration file";

    private String newFilePath;
    private static Config config;
    private static Storage storage;
    private static JsonUserConfigStorage jsonUserConfigStorage;

    public SaveCommand(String filePath) {
        this.newFilePath = filePath;
        jsonUserConfigStorage = new JsonUserConfigStorage(Config.DEFAULT_CONFIG_FILE);
    }

    public static void setStorage(Storage storageToSet) {
        storage = storageToSet;
    }

    public static void setConfig(Config configToset) {
        config = configToset;
    }

    @Override
    public CommandResult execute() throws CommandException {
        ReadOnlyWhatsLeft whatsLeftToSave = model.getWhatsLeft();
        try {
            String fileToSave = newFilePath + "/whatsleft.xml";
            storage.saveWhatsLeft(whatsLeftToSave, fileToSave);
            config.setWhatsLeftFilePath(fileToSave);
            saveConfig();
            indicateConfigChanged();
        } catch (IOException e) {
            throw new CommandException(Messages.MESSAGE_INVALID_FILEPATH);
        }
        return new CommandResult(String.format(MESSAGE_CHANGE_FILEPATH_SUCCESS, newFilePath));
    }

    private void indicateConfigChanged() {
        EventsCenter.getInstance().post(new ConfigChangedEvent(config));
    }

    private void saveConfig() throws CommandException {
        try {
            jsonUserConfigStorage.saveUserConfig(config);
        } catch (IOException e) {
            throw new CommandException(MESSAGE_SAVE_CONFIG_ERROR);
        }
    }
}
```
###### /java/seedu/address/logic/commands/ShowCommand.java
``` java

/**
 * Updates the display preference of tasks in WhatsLeft.
 */

public class ShowCommand extends Command {

    public static final String COMMAND_WORD = "show";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": changes the current display status preference "
            + "to show completed, pending or all tasks "
            + "Parameters: STATUS PREFERENCE (com shows complete tasks, pend shows pending tasks, all shows all tasks"
            + "[com/pend/all]"
            + "Example: " + COMMAND_WORD + " com";

    public static final String MESSAGE_DISPLAY_PREFERENCE_SUCCESS = "Successfully changed display"
            + " preference to show [%1$s] tasks";

    private final String displayPreference;

    public ShowCommand(String displayPreference) {
        assert displayPreference.equals("") | displayPreference.equals("com") | displayPreference.equals("pend");

        this.displayPreference = displayPreference;
    }

    @Override
    public CommandResult execute() throws CommandException {
        String preference;
        if (displayPreference.equals("com")) {
            preference = "COMPLETED";
        } else if (displayPreference.equals("pend")) {
            preference = "PENDING";
        } else if (displayPreference.equals("")) {
            preference = "ALL";
        } else {
            throw new CommandException(Messages.MESSAGE_INVALID_DISPLAY_STATUS_KEYWORD);
        }
        model.setDisplayStatus(preference);
        model.updateFilteredListToShowAll();
        indicateShowStatusChanged();
        return new CommandResult(String.format(MESSAGE_DISPLAY_PREFERENCE_SUCCESS, preference));
    }

    private void indicateShowStatusChanged() {
        EventsCenter.getInstance().post(new ShowStatusChangedEvent(model.getDisplayStatus()));
    }

```
###### /java/seedu/address/logic/parser/FinishCommandParser.java
``` java
/**
 * Parses input arguments and creates a new FinishCommand object
 */

public class FinishCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the FinishCommand
     * and returns an FinishCommand object for execution.
     */
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndexAlone(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, FinishCommand.MESSAGE_USAGE));
        }

        return new FinishCommand(index.get());
    }

}
```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    /**
     * Returns the specified location in the {@code command}
     * Returns an {@code Optional.empty()} otherwise
     * @param command
     * @return
     */
    public static Optional<String> parseFilePath(String command) {
        final Matcher matcher = CONFIG_FILEPATH_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String filePath = matcher.group("filepath");
        return Optional.of(filePath);
    }

```
###### /java/seedu/address/logic/parser/ParserUtil.java
``` java
    public static String parseStatus(String command) {
        String trimmedCommand = command.trim();
        return trimmedCommand;
    }

```
###### /java/seedu/address/logic/parser/ReadCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RedoCommand object
 */

public class ReadCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ReadCommand
     * and returns an RedoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<String> filePath = ParserUtil.parseFilePath(args);
        if (!filePath.isPresent() || filePath.get().equals("")) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ReadCommand.MESSAGE_USAGE));
        }
        return new ReadCommand(filePath.get());
    }
}
```
###### /java/seedu/address/logic/parser/RedoCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RedoCommand object
 */

public class RedoCommandParser {
    /**
     * Parses the given {@code String} of arguments in the context of the RedoCommand
     * and returns an RedoCommand object for execution.
     */
    public Command parse(String args) {

        Optional<Integer> index = ParserUtil.parseIndexAlone(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, RedoCommand.MESSAGE_USAGE));
        }

        return new RedoCommand(index.get());
    }

}
```
###### /java/seedu/address/logic/parser/SaveCommandParser.java
``` java
/**
 * Parses input arguments and creates a new RedoCommand object
 */

public class SaveCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the SaveCommand
     * and returns an RedoCommand object for execution.
     */
    public Command parse(String args) {
        Optional<String> filePath = ParserUtil.parseFilePath(args);
        if (!filePath.isPresent() || filePath.get().equals("")) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, SaveCommand.MESSAGE_USAGE));
        }
        return new SaveCommand(filePath.get());
    }
}
```
###### /java/seedu/address/logic/parser/ShowCommandParser.java
``` java
/**
 * Parses input arguments and creates a new ShowCommand object
 */
public class ShowCommandParser {

    /**
     * Parses the given {@code String} of arguments in the context of the ShowCommand
     * and returns an ShowCommand object for execution.
     */

    public Command parse(String args) {

        String status = ParserUtil.parseStatus(args);

        if (!status.equals("com") && !status.equals("pend") && !status.equals("")) {
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, ShowCommand.MESSAGE_USAGE));
        }

        return new ShowCommand(status);
    }
}
```
###### /java/seedu/address/model/Model.java
``` java
    /** Sets the display status in model */
    void setDisplayStatus(String status);

    /** returns the current display status in model */
    String getDisplayStatus();

```
###### /java/seedu/address/model/ModelManager.java
``` java
    /**
     * Initializes a ModelManager with the given whatsLeft and userPrefs.
     */
    public ModelManager(ReadOnlyWhatsLeft whatsLeft, UserPrefs userPrefs) {
        super();
        assert !CollectionUtil.isAnyNull(whatsLeft, userPrefs);

        logger.fine("Initializing with WhatsLeft: " + whatsLeft + " and user prefs " + userPrefs);

        this.whatsLeft = new WhatsLeft(whatsLeft);
        previousState = new WhatsLeft();
        filteredEvents = new FilteredList<>(this.whatsLeft.getEventList());
        filteredTasks = new FilteredList<>(this.whatsLeft.getTaskList());
        previousCommand = "";
        displayStatus = DISPLAY_STATUS_PENDING;
        updateFilteredListToShowAll();
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public synchronized void markTaskAsComplete(ReadOnlyTask taskToMark) throws TaskNotFoundException {
        whatsLeft.completeTask(taskToMark);
        updateFilteredListToShowAll();
        indicateWhatsLeftChanged();
    }

    @Override
    public synchronized void markTaskAsPending(ReadOnlyTask taskToMark) throws TaskNotFoundException {
        whatsLeft.redoTask(taskToMark);
        updateFilteredListToShowAll();
        indicateWhatsLeftChanged();
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        try {
            if (displayStatus.equals(DISPLAY_STATUS_ALL)) {
                filteredTasks.setPredicate(null);
                filteredEvents.setPredicate(null);
            } else if (displayStatus.equals(DISPLAY_STATUS_COMPLETED)) {
                filteredTasks.setPredicate(new PredicateExpression(new StatusQualifier(true))::satisfies);
                filteredEvents.setPredicate(new PredicateExpression(new StatusQualifier(true))::satisfies);
            } else if (displayStatus.equals(DISPLAY_STATUS_PENDING)) {
                filteredTasks.setPredicate(new PredicateExpression(new StatusQualifier(false))::satisfies);
                filteredEvents.setPredicate(new PredicateExpression(new StatusQualifier(false))::satisfies);
            } else {
                throw new IllegalValueException("Wrong model manager display status");
            }
        } catch (IllegalValueException e) {
            System.out.print(e);
        }
    }

    @Override
    public void updateFilteredTaskList(Set<String> keywords) {
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords, displayStatus)));
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private void updateFilteredTaskList(Expression expression) {
        filteredTasks.setPredicate(expression::satisfies);
    }

    @Override
    public void updateFilteredEventList(Set<String> keywords) {
        updateFilteredEventList(new PredicateExpression(new NameQualifier(keywords, displayStatus)));
    }

    private void updateFilteredEventList(Expression expression) {
        filteredEvents.setPredicate(expression::satisfies);
    }

    // ========== Inner classes/interfaces used for filtering
    // =================================================
```
###### /java/seedu/address/model/ModelManager.java
``` java
    interface Expression {
        boolean satisfies(ReadOnlyTask task);

        boolean satisfies(ReadOnlyEvent event);

        String toString();
    }

    private class PredicateExpression implements Expression {

        private final Qualifier qualifier;

        PredicateExpression(Qualifier qualifier) {
            this.qualifier = qualifier;
        }

        @Override
        public boolean satisfies(ReadOnlyTask task) {
            return qualifier.run(task);
        }

        @Override
        public boolean satisfies(ReadOnlyEvent event) {
            return qualifier.run(event);
        }

        @Override
        public String toString() {
            return qualifier.toString();
        }
    }

    interface Qualifier {
        boolean run(ReadOnlyTask task);

        boolean run(ReadOnlyEvent event);

        String toString();
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class NameQualifier implements Qualifier {
        private Set<String> nameKeyWords;
        private String displayStatus;

        NameQualifier(Set<String> nameKeyWords, String status) {
            this.nameKeyWords = nameKeyWords;
            this.displayStatus = status;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (displayStatus.equals(DISPLAY_STATUS_ALL)) {
                return nameKeyWords.stream().filter(
                    keyword -> StringUtil.containsWordIgnoreCase(task.getDescription().description, keyword))
                        .findAny().isPresent();
            } else if (displayStatus.equals(DISPLAY_STATUS_COMPLETED)) {
                return nameKeyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getDescription().description, keyword)
                                && task.getStatus())
                        .findAny().isPresent();
            } else if (displayStatus.equals(DISPLAY_STATUS_PENDING)) {
                return nameKeyWords.stream()
                        .filter(keyword -> StringUtil.containsWordIgnoreCase(task.getDescription().description, keyword)
                                && !task.getStatus())
                        .findAny().isPresent();
            } else {
                try {
                    throw new IllegalValueException("Wrong qualifier display status");
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
                return false;
            }
        }

        @Override
        public boolean run(ReadOnlyEvent event) {
            if (displayStatus.equals(DISPLAY_STATUS_ALL)) {
                return nameKeyWords.stream().filter(
                    keyword -> StringUtil.containsWordIgnoreCase(event.getDescription().description, keyword))
                        .findAny().isPresent();
            } else if (displayStatus.equals(DISPLAY_STATUS_COMPLETED)) {
                return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(event.getDescription().description, keyword)
                                && event.isOver())
                        .findAny().isPresent();
            } else if (displayStatus.equals(DISPLAY_STATUS_PENDING)) {
                return nameKeyWords.stream()
                    .filter(keyword -> StringUtil.containsWordIgnoreCase(event.getDescription().description, keyword)
                                && !event.isOver())
                        .findAny().isPresent();
            } else {
                try {
                    throw new IllegalValueException("Wrong qualifier display status");
                } catch (IllegalValueException e) {
                    e.printStackTrace();
                }
                return false;
            }
        }

        @Override
        public String toString() {
            return "name=" + String.join(", ", nameKeyWords) + " Displat Status: " + displayStatus;
        }
    }
```
###### /java/seedu/address/model/ModelManager.java
``` java
    private class StatusQualifier implements Qualifier {
        private boolean statusKey;

        StatusQualifier(boolean statusKey) {
            this.statusKey = statusKey;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            return task.getStatus() == statusKey;
        }

        @Override
        public boolean run(ReadOnlyEvent event) {
            if (statusKey) {
                return event.isOver();
            } else {
                return !event.isOver();
            }
        }
```
###### /java/seedu/address/model/person/ByDate.java
``` java
/**
 * Represents a Deadline's ByDate in WhatsLeft.
 * Guarantees: immutable; is valid as declared in {@link #isValidByDate(String)}
 */
public class ByDate {

    public static final String MESSAGE_BYDATE_CONSTRAINTS =
            "Deadline ByDate can take only 6 digits, and it should be in DDMMYY format (Day-Month-Year)";

    public final LocalDate value;
    public final boolean isExisting;

    public LocalDate getValue() {
        return value;
    }

```
###### /java/seedu/address/model/person/ByDate.java
``` java
    /*
     * For JAXB use
     */
    public ByDate(LocalDate bydate) {
        value = bydate;
        if (bydate == null) {
            isExisting = false;
        } else {
            isExisting = true;
        }
    }

```
###### /java/seedu/address/model/person/ByTime.java
``` java
/**
 * Represents a Deadline's ByTime in WhatsLeft.
 * Guarantees: immutable; is valid as declared in {@link #isValidByTime(String)}
 */
public class ByTime {

    public static final String MESSAGE_BYTIME_CONSTRAINTS =
            "Deadline ByTime can only be in this format: hhmm, e.g. 1300";

    public final LocalTime value;
    public final boolean isExisting;

```
###### /java/seedu/address/model/person/ByTime.java
``` java
    /**
     * Validates given start time.
     * @param byTime Argument in string format
     * @throws IllegalValueException if given start time is invalid.
     */
    public ByTime(String byTimeArg) throws IllegalValueException {
        if (byTimeArg == null) {
            this.value = null;
            this.isExisting = false;
        } else {
            try {
                this.value = StringUtil.parseStringToTime(byTimeArg);
                this.isExisting = true;
            } catch (DateTimeException illegalValueException) {
                throw new IllegalValueException(MESSAGE_BYTIME_CONSTRAINTS);
            }
        }
    }

```
###### /java/seedu/address/model/person/ByTime.java
``` java
    /**
     * For JAXB use
     */
    public ByTime(LocalTime bytime) {
        value = bytime;
        if (bytime == null) {
            isExisting = false;
        } else {
            isExisting = true;
        }
    }

    public LocalTime getValue() {
        return value;
    }

    @Override
    public String toString() {
        if (value == null) {
            return null;
        }
        return value.toString();
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ByTime // instanceof handles nulls
                && this.value.equals(((ByTime) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

```
###### /java/seedu/address/model/person/Event.java
``` java

    /**
     * Checks if start Date/Time is before end Date/Time
     */
    public static boolean isValideEndDateTime(EndTime et, EndDate ed, StartTime st, StartDate sd) {
        if (sd.getValue().isAfter(ed.getValue())) {
            return false;
        }
        if (sd.getValue().equals(ed.getValue()) && st.getValue().isAfter(et.getValue())) {
            return false;
        }
        return true;
    }

```
###### /java/seedu/address/model/person/Event.java
``` java
    /**
     * Replaces this event's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }

    /**
     * Updates this event with the details of {@code replacement}.
     */
    public void resetData(ReadOnlyEvent replacement) {
        assert replacement != null;

        this.setDescription(replacement.getDescription());
        this.setStartTime(replacement.getStartTime());
        this.setStartDate(replacement.getStartDate());
        this.setEndTime(replacement.getEndTime());
        this.setEndDate(replacement.getEndDate());
        this.setLocation(replacement.getLocation());
        this.setTags(replacement.getTags());
    }

```
###### /java/seedu/address/model/person/Event.java
``` java
    @Override
    public boolean isOver() {
        if (LocalDate.now().isAfter(this.getEndDate().getValue())) {
            return true;
        } else if (LocalDate.now().isBefore(this.getEndDate().getValue())) {
            return false;
        } else {
            if (LocalTime.now().isAfter(this.getEndTime().getValue())) {
                return true;
            } else {
                return false;
            }
        }
    }
```
###### /java/seedu/address/model/person/Event.java
``` java

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyEvent // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyEvent) other));
    }

    @Override
    public int hashCode() {
        // use this method for custend fields hashing instead of implementing your own
        return Objects.hash(description, startTime, startDate, endTime, endDate, location, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }
}
```
###### /java/seedu/address/model/person/ReadOnlyEvent.java
``` java
    /**
     * Check with current date/time to see if the event is over.
     */
    boolean isOver();
```
###### /java/seedu/address/model/person/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || (other != null // this is first to avoid NPE below
                && (other.getDescription().toString() == null ? this.getDescription().toString() == null :
                    other.getDescription().toString().equals(this.getDescription().
                            toString())) // state checks here onwards
                && (other.getPriority().toString() == null ? this.getPriority().toString() == null :
                    other.getPriority().toString().equals(this.getPriority().toString()))
                && (other.getByDate().toString() == null ? this.getByDate().toString() == null :
                    other.getByDate().toString().equals(this.getByDate().toString()))
                && (other.getByTime().toString() == null ? this.getByTime().toString() == null :
                    other.getByTime().toString().equals(this.getByTime().toString()))
                && (other.getLocation().toString() == null ? this.getLocation().toString() == null :
                    other.getLocation().toString().equals(this.getLocation().toString()))
                && (other.getTags().equals(this.getTags()))
                && (other.getStatus() == this.getStatus())
                );
    }
```
###### /java/seedu/address/model/person/StartDate.java
``` java
    /*
     * for JAXB use
     */
    public StartDate(LocalDate startDate) {
        value = startDate;
    }

    public LocalDate getValue() {
        return value;
    }

```
###### /java/seedu/address/model/person/Task.java
``` java
public class Task implements ReadOnlyTask {

    public static final boolean DEFAULT_TASK_STATUS = false;
    public static final boolean COMPLETED_TASK_STATUS = true;

    private Description description;
    private Priority priority;
    private ByTime byTime;
    private ByDate byDate;
    private Location location;
    private boolean status;

    private UniqueTagList tags;

    /**
     * Description and Priority must be present.
     */
    public Task(Description description, Priority priority, ByTime byTime, ByDate byDate,
            Location location, UniqueTagList tags, boolean status) {

        assert !CollectionUtil.isAnyNull(description, priority, tags);
        this.description = description;
        this.priority = priority;
        this.byTime = byTime;
        this.byDate = byDate;
        this.location = location;
        this.status = status;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
```
###### /java/seedu/address/model/person/Task.java
``` java
    /**
     * Mark a task as complete
     */

    public void completeTask() {
        this.status = true;
    }

    /**
     * Mark a task as pending
     */
    public void redoTask() {
        this.status = false;

    }
```
###### /java/seedu/address/model/person/Task.java
``` java
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ReadOnlyTask // instanceof handles nulls
                && this.isSameStateAs((ReadOnlyTask) other));
    }

    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(description, byDate, byTime, location, tags);
    }

    @Override
    public String toString() {
        return getAsText();
    }

}
```
###### /java/seedu/address/model/person/UniqueTaskList.java
``` java
    /**
     * Marks the task in the list at position {@code index} as complete.
     * @param task to mark as complete in ReadOnlyTask format
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void completeTask(ReadOnlyTask taskToMark) {
        Task taskToComplete = new Task(taskToMark);
        int index = internalList.indexOf(taskToComplete);
        taskToComplete.completeTask();
        internalList.set(index, taskToComplete);
    }

    /**
     * Marks the task in the list at position {@code index} as pending.
     *
     * @throws IndexOutOfBoundsException if {@code index} < 0 or >= the size of the list.
     */
    public void redoTask(ReadOnlyTask taskToMark) {
        Task taskToComplete = new Task(taskToMark);
        int index = internalList.indexOf(taskToComplete);
        taskToComplete.redoTask();
        internalList.set(index, taskToComplete);
    }
```
###### /java/seedu/address/storage/JsonUserConfigStorage.java
``` java
/**
 * A class to access UserConfig stored in the hard disk as a json file
 */
public class JsonUserConfigStorage implements UserConfigStorage {

    private String filePath;

    public JsonUserConfigStorage(String filePath) {
        this.filePath = filePath;
    }

    @Override
    public Optional<Config> readUserConfig() throws DataConversionException, IOException {
        return readUserConfig(filePath);
    }

    /**
     * Similar to {@link #readUserConfig()}
     * @param configFilePath location of the data. Cannot be null.
     * @throws DataConversionException if the file format is not as expected.
     */
    public Optional<Config> readUserConfig(String configFilePath) throws DataConversionException {
        return JsonUtil.readJsonFile(configFilePath, Config.class);
    }

    @Override
    public void saveUserConfig(Config config) throws IOException {
        JsonUtil.saveJsonFile(config, filePath);
    }

}
```
###### /java/seedu/address/storage/LocalDateAdapter.java
``` java
/*
 * Adapter used for marshaling LocalDate using JAXB
 */
public class LocalDateAdapter extends XmlAdapter<String, LocalDate> {
    public LocalDate unmarshal(String v) throws Exception {
        return LocalDate.parse(v);
    }

    public String marshal(LocalDate v) throws Exception {
        return v.toString();
    }
}
```
###### /java/seedu/address/storage/LocalTimeAdapter.java
``` java
/*
 * Adapter used for marshaling LocalTime using JAXB
 */
public class LocalTimeAdapter extends XmlAdapter<String, LocalTime> {
    public LocalTime unmarshal(String v) throws Exception {
        return LocalTime.parse(v);
    }

    public String marshal(LocalTime v) throws Exception {
        return v.toString();
    }
}
```
###### /java/seedu/address/storage/UserConfigStorage.java
``` java
/**
 * Represents a storage for {@link seedu.address.commons.core.Config}.
 */
public interface UserConfigStorage {

    /**
     * Returns Configuration data from storage.
     *   Returns {@code Optional.empty()} if storage file is not found.
     * @throws DataConversionException if the data in storage is not in the expected format.
     * @throws IOException if there was any problem when reading from the storage.
     */
    Optional<Config> readUserConfig() throws DataConversionException, IOException;

    /**
     * Saves the given {@link seedu.address.commons.core.Config} to the storage.
     * @param config cannot be null.
     * @throws IOException if there was any problem writing to the file.
     */
    void saveUserConfig(Config config) throws IOException;

}
```
###### /java/seedu/address/storage/WhatsLeftStorage.java
``` java
    /**
     * Sets the new storage location of the data file
     */
    void setWhatsLeftFilePath(String filepath);

    /**
     * Returns WhatsLeft data as a {@link ReadOnlyWhatsLeft}.
     *   Returns {@code Optional.empty()} if storage file is not found.
     * @throws DataConversionException if the data in storage is not in the expected format.
     * @throws IOException if there was any problem when reading from the storage.
     */
```
###### /java/seedu/address/storage/XmlAdaptedEvent.java
``` java
/**
 * JAXB-friendly version of the Event.
 */
public class XmlAdaptedEvent {

    @XmlElement(required = true)
    private String description;
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(LocalTimeAdapter.class)
    private LocalTime startTime;
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(LocalDateAdapter.class)
    private LocalDate startDate;
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(LocalTimeAdapter.class)
    private LocalTime endTime;
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(LocalDateAdapter.class)
    private LocalDate endDate;
    @XmlElement(required = true)
    private String location;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * Constructs an XmlAdaptedEvent.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedEvent() {}

```
###### /java/seedu/address/storage/XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String description;
    @XmlElement(required = true)
    private String priority;
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(LocalTimeAdapter.class)
    private LocalTime byTime;
    @XmlElement(required = true)
    @XmlJavaTypeAdapter(LocalDateAdapter.class)
    private LocalDate byDate;
    @XmlElement(required = true)
    private String location;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();
    @XmlElement(required = true)
    private boolean status;

    /**
     * Constructs an XmlAdaptedTask.
     * This is the no-arg constructor that is required by JAXB.
     */
    public XmlAdaptedTask() {}

```
###### /java/seedu/address/storage/XmlSerializableWhatsLeft.java
``` java
/**
 * An Immutable WhatsLeft that is serializable to XML format
 */
@XmlRootElement(name = "whatsleft")
public class XmlSerializableWhatsLeft implements ReadOnlyWhatsLeft {

    @XmlElement
    private List<XmlAdaptedTask> tasks;
    @XmlElement
    private List<XmlAdaptedEvent> events;
    @XmlElement
    private List<XmlAdaptedTag> tags;

    /**
     * Creates an empty XmlSerializableWhatsLeft.
     * This empty constructor is required for marshalling.
     */
    public XmlSerializableWhatsLeft() {
        tasks = new ArrayList<>();
        events = new ArrayList<>();
        tags = new ArrayList<>();
    }

    /**
     * Conversion
     */
    public XmlSerializableWhatsLeft(ReadOnlyWhatsLeft src) {
        this();
        tasks.addAll(src.getTaskList().stream().map(XmlAdaptedTask::new).collect(Collectors.toList()));
        events.addAll(src.getEventList().stream().map(XmlAdaptedEvent::new).collect(Collectors.toList()));
        tags.addAll(src.getTagList().stream().map(XmlAdaptedTag::new).collect(Collectors.toList()));
    }
```
###### /java/seedu/address/ui/StatusBarFooter.java
``` java
    private void setDisplayStatus(String displayStatus) {
        this.displayStatus.setText(displayStatus);
    }
```
###### /java/seedu/address/ui/StatusBarFooter.java
``` java
    @Subscribe
    public void handleConfigChangedEvent(ConfigChangedEvent cce) {
        String newLocation = cce.data.getWhatsLeftFilePath();
        logger.info(LogsCenter.getEventHandlingLogMessage(cce, "Setting save location to " + newLocation));
        setSaveLocation(newLocation);
    }

    @Subscribe
    public void handleShowStatusChangedEvent(ShowStatusChangedEvent ssce) {
        String showStatus = ssce.toString();
        logger.info(LogsCenter.getEventHandlingLogMessage(ssce, ""));
        setDisplayStatus(showStatus);
    }
```
